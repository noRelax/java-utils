/* MetricsAnalyzer
 * Copyright (C) 2002  TIKE (tike.mmm.fi)
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 59
 * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package metricsanalyzer.importer;

import java.io.File;
import javax.xml.parsers.SAXParserFactory;
import metricsanalyzer.api.data.Attr;
import metricsanalyzer.api.data.Relation;
import metricsanalyzer.api.data.TableBuilder;
import metricsanalyzer.api.ext.Importer;
import metricsanalyzer.util.Strings;
import metricsanalyzer.util.xml.SAXDispatchHandler;

/**
 * Imports metrics from XML files generated by JavaNCSS.
 */
public class JavaNCSSXMLImporter extends Importer {
  public void doImport(File file,
                       TableBuilder tableBuilder) throws Exception {
    SAXParserFactory.newInstance().newSAXParser().parse(file, new Handler(tableBuilder));
  }

  public Relation[] getRelations() {
    return RELATIONS;
  }

  private static final Attr
    PACKAGE_NAME_ATTR  = new Attr("package_id",  "shared_str"),
    CLASS_NAME_ATTR    = new Attr("class_id",    "shared_str"),
    FUNCTION_NAME_ATTR = new Attr("function_id", "shared_str"),
    NCSS_ATTR          = new Attr("ncss",        "int"),
    CCN_ATTR           = new Attr("ccn",         "int");

  private static final Relation
    PACKAGE_RELATION  = new Relation("package",
                                     new Attr[]{PACKAGE_NAME_ATTR},
                                     new Attr[]{NCSS_ATTR}),
    CLASS_RELATION    = new Relation("class",
                                     new Attr[]{CLASS_NAME_ATTR,
                                                PACKAGE_NAME_ATTR},
                                     new Attr[]{NCSS_ATTR}),
    FUNCTION_RELATION = new Relation("function",
                                     new Attr[]{FUNCTION_NAME_ATTR,
                                                CLASS_NAME_ATTR,
                                                PACKAGE_NAME_ATTR},
                                     new Attr[]{NCSS_ATTR,
                                                CCN_ATTR});

  private static final Relation[] RELATIONS = {
    PACKAGE_RELATION,
    CLASS_RELATION,
    FUNCTION_RELATION};

  public static class Handler extends SAXDispatchHandler {
    Handler(TableBuilder tableBuilder) throws Exception {
      this.tableBuilder = tableBuilder;
    }

    public void chars_name_function(String data) {
      setFunctionName(data);
    }

    public void chars_ncss_function(String data) throws Exception {
      if (null != functionName)
        tableBuilder.add(FUNCTION_RELATION,
                         new Object[]{functionName, className, packageName},
                         new Object[]{new Integer(data), null});
    }

    public void chars_ccn_function(String data) throws Exception {
      if (null != functionName)
        tableBuilder.add(FUNCTION_RELATION,
                         new Object[]{functionName, className, packageName},
                         new Object[]{null, new Integer(data)});
    }

    public void chars_name_object(String data) {
      setClassName(data);
    }

    public void chars_ncss_object(String data) throws Exception {
      if (null != className)
        tableBuilder.add(CLASS_RELATION,
                         new Object[]{className, packageName},
                         new Object[]{new Integer(data)});
    }

    public void chars_name_package(String data) {
      set(data,
          null,
          null);
    }

    public void chars_ncss_package(String data) throws Exception {
      if (null != packageName)
        tableBuilder.add(PACKAGE_RELATION,
                         new Object[]{packageName},
                         new Object[]{new Integer(data)});
    }

    private void setFunctionName(String rawFunctionName) {
      int functionNameEnd = rawFunctionName.indexOf('(');
      int classNameEnd = rawFunctionName.lastIndexOf('.', functionNameEnd);
      int packageNameEnd = rawFunctionName.lastIndexOf('.', classNameEnd - 1);

      set(rawFunctionName.substring(0,
                                    -1 == packageNameEnd ? 0 : packageNameEnd),
          rawFunctionName.substring(-1 == packageNameEnd ? 0 : packageNameEnd + 1,
                                    -1 == classNameEnd ? 0 : classNameEnd),
          rawFunctionName.substring(-1 == classNameEnd ? 0 : classNameEnd + 1));
    }

    private void setClassName(String rawClassName) {
      int packageNameEnd = rawClassName.lastIndexOf('.');

      set(rawClassName.substring(0,
                                 -1 == packageNameEnd ? 0 : packageNameEnd),
          rawClassName.substring(-1 == packageNameEnd ? 0 : packageNameEnd + 1),
          null);
    }

    private void set(String newPackageName, String newClassName, String newFunctionName) {
      packageName = newPackageName;
      className = newClassName;
      functionName = newFunctionName;

      if (Strings.hasUpperCaseChar(newPackageName) || 0 == newPackageName.length()) {
        // Inner classes are completely skipped, because JavaNCSS may map
        // multiple inner classes to the same name. This should be probably
        // be changed in JavaNCSS.

        System.err.println(composeErrorMsg("WARNING: Ignoring: "));

        packageName = null;
        className = null;
        functionName = null;
      }
    }

    private String composeErrorMsg(String prefix) {
      StringBuffer result = new StringBuffer(prefix);

      result.append(packageName).append(".").append(className).append(".").append(functionName).append("\n");

      if (0 < stateStack.size()) {
        result.append("StateStack: ").append(stateStack.top(1));
        for (int i=2; i<=stateStack.size(); ++i)
          result.append(", ").append(stateStack.top(i));
      } else {
        result.append("StateStack is empty.");
      }
      return result.toString();
    }

    private String packageName;
    private String className;
    private String functionName;

    private TableBuilder tableBuilder;
  }
}
